<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entraînement Devanagari</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .group-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .group-btn {
            padding: 8px 16px;
            background: #e0e0e0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .group-btn.active {
            background: #007bff;
            color: white;
        }
        
        .group-btn:hover {
            background: #0056b3;
            color: white;
        }
        
        .exercise-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .letter-display {
            text-align: center;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            order: 2;
        }
        
        .current-letter {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin: 5px 0;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            transition: all 0.3s;
            min-width: 60px;
            display: inline-block;
        }
        
        .current-letter:hover {
            background-color: #e9ecef;
            transform: scale(1.05);
        }
        
        .current-letter.latin {
            font-family: 'Times New Roman', serif;
        }
        
        .current-letter.devanagari {
            font-family: 'Noto Sans Devanagari', sans-serif;
            font-size: 32px;
            color: #007bff;
        }
        
        .devanagari-letter {
            font-size: 72px;
            color: #007bff;
            margin: 20px 0;
            font-family: 'Noto Sans Devanagari', sans-serif;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .canvas-area {
            text-align: center;
            order: 1;
        }
        
        #drawingCanvas {
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: crosshair;
            background: white;
            max-width: 100%;
            height: auto;
        }
        
        .canvas-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .canvas-item {
            text-align: center;
        }
        
        .canvas-item h4 {
            margin: 10px 0 5px 0;
            font-size: 14px;
            color: #666;
        }
        
        #referenceCanvas, #comparisonCanvas {
            border: 2px solid #ddd;
            border-radius: 5px;
            background: white;
            width: 200px;
            height: 200px;
        }
        
        .similarity-score {
            background: #e8f4fd;
            border: 2px solid #007bff;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }
        
        .realtime-score {
            background: #f0f8ff;
            border: 2px solid #4a90e2;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #2c5aa0;
        }
        
        .switch-indicator {
            color: #999;
            font-size: 12px;
            margin-left: 5px;
            vertical-align: middle;
        }
        
        .score-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
            margin: 5px 0;
        }
        
        .score-label {
            color: #666;
            font-size: 14px;
        }
        
        .canvas-controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0056b3;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #545b62;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #1e7e34;
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        .evaluation {
            text-align: center;
            margin-top: 20px;
        }
        
        .evaluation-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
        }
        
        .stats {
            background: #e9ecef;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: center;
        }
        
        .show-answer-btn {
            background: #17a2b8;
            color: white;
            margin-top: 10px;
        }
        
        .show-answer-btn:hover {
            background: #138496;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 24px;
                margin-bottom: 20px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }
            
            .group-selector {
                justify-content: center;
            }
            
            .group-btn {
                padding: 10px 12px;
                font-size: 14px;
            }
            
            #drawingCanvas {
                width: 280px;
                height: 280px;
            }
            
            .current-letter {
                font-size: 20px;
            }
            
            .current-letter.devanagari {
                font-size: 28px;
            }
            
            .switch-indicator {
                font-size: 10px;
            }
            
            .devanagari-letter {
                font-size: 48px;
                min-height: 70px;
            }
            
            .canvas-controls {
                flex-direction: column;
                gap: 8px;
                align-items: center;
            }
            
            .btn {
                padding: 12px 20px;
                font-size: 16px;
                min-width: 120px;
            }
            
            .evaluation-buttons {
                flex-direction: column;
                gap: 10px;
                align-items: center;
            }
            
            .stats {
                font-size: 14px;
                padding: 10px;
            }
            
            #canvasContainer {
                flex-direction: column;
                align-items: center;
            }
            
            #referenceCanvas, #comparisonCanvas {
                width: 150px;
                height: 150px;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Devanagari:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <h1>Entraînement à l'écriture du Devanagari</h1>
        
        <div class="controls">
            <div class="group-selector">
                <button class="group-btn active" data-group="all">Toutes</button>
                <button class="group-btn" data-group="voyelles">Voyelles</button>
                <button class="group-btn" data-group="palatales">Palatales</button>
                <button class="group-btn" data-group="cerebrales">Cérébrales</button>
                <button class="group-btn" data-group="dentales">Dentales</button>
                <button class="group-btn" data-group="labiales">Labiales</button>
                <button class="group-btn" data-group="autres">Autres</button>
            </div>
        </div>
        
        <div class="exercise-area">
            <div class="canvas-area">
                <div class="letter-prompt">
                    Dessinez la lettre : <span class="current-letter latin" id="currentLetter" title="Cliquez pour basculer">a</span> <span style="color: #007bff; font-size: 14px; font-weight: bold; margin-left: 8px;">⇄</span>
                </div>
                
                <canvas id="drawingCanvas" width="300" height="300"></canvas>
                <div class="realtime-score" id="realtimeScore">Score en temps réel : 0%</div>
                
                <div class="canvas-controls">
                    <button class="btn btn-secondary" id="clearBtn">Effacer</button>
                    <button class="btn btn-primary" id="analyzeBtn">Analyser</button>
                    <button class="btn btn-primary" id="nextBtn">Suivant</button>
                </div>
                
                <div class="similarity-score" id="similarityScore" style="display: none;">
                    <div class="score-label">Degré de proximité</div>
                    <div class="score-value" id="scoreValue">0%</div>
                </div>
                
                <div class="canvas-container" id="canvasContainer" style="display: none;">
                    <div class="canvas-item">
                        <h4>Référence</h4>
                        <canvas id="referenceCanvas" width="200" height="200"></canvas>
                    </div>
                    <div class="canvas-item">
                        <h4>Comparaison</h4>
                        <canvas id="comparisonCanvas" width="200" height="200"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="evaluation">
            <h3>Comment évaluez-vous votre dessin ?</h3>
            <div class="evaluation-buttons">
                <button class="btn btn-success" id="okBtn">✓ OK</button>
                <button class="btn btn-danger" id="nokBtn">✗ NOK</button>
            </div>
        </div>
        
        <div class="stats">
            <p><strong>Statistiques :</strong></p>
            <p>Lettres pratiquées : <span id="practiceCount">0</span> | 
               Réussies : <span id="successCount">0</span> | 
               Taux de réussite : <span id="successRate">0%</span></p>
            <p style="margin-top: 10px; font-size: 12px; color: #666;">
                <a href="https://github.com/l0d0v1c/devanagaritrain" target="_blank" style="color: #007bff; text-decoration: none;">💻 Code source sur GitHub</a>
            </p>
        </div>
    </div>

    <script>
        $(document).ready(function() {
            // Données des lettres devanagari organisées par groupes
            const devanagariData = {
                voyelles: [
                    {latin: 'a', devanagari: 'अ', frequency: 1},
                    {latin: 'ā', devanagari: 'आ', frequency: 1},
                    {latin: 'i', devanagari: 'इ', frequency: 1},
                    {latin: 'ī', devanagari: 'ई', frequency: 1},
                    {latin: 'u', devanagari: 'उ', frequency: 1},
                    {latin: 'ū', devanagari: 'ऊ', frequency: 1},
                    {latin: 'e', devanagari: 'ए', frequency: 1},
                    {latin: 'o', devanagari: 'ओ', frequency: 1}
                ],
                palatales: [
                    {latin: 'ca', devanagari: 'च', frequency: 1},
                    {latin: 'cha', devanagari: 'छ', frequency: 1},
                    {latin: 'ja', devanagari: 'ज', frequency: 1},
                    {latin: 'jha', devanagari: 'झ', frequency: 1},
                    {latin: 'ña', devanagari: 'ञ', frequency: 1}
                ],
                cerebrales: [
                    {latin: 'ṭa', devanagari: 'ट', frequency: 1},
                    {latin: 'ṭha', devanagari: 'ठ', frequency: 1},
                    {latin: 'ḍa', devanagari: 'ड', frequency: 1},
                    {latin: 'ḍha', devanagari: 'ढ', frequency: 1},
                    {latin: 'ṇa', devanagari: 'ण', frequency: 1}
                ],
                dentales: [
                    {latin: 'ta', devanagari: 'त', frequency: 1},
                    {latin: 'tha', devanagari: 'थ', frequency: 1},
                    {latin: 'da', devanagari: 'द', frequency: 1},
                    {latin: 'dha', devanagari: 'ध', frequency: 1},
                    {latin: 'na', devanagari: 'न', frequency: 1}
                ],
                labiales: [
                    {latin: 'pa', devanagari: 'प', frequency: 1},
                    {latin: 'pha', devanagari: 'फ', frequency: 1},
                    {latin: 'ba', devanagari: 'ब', frequency: 1},
                    {latin: 'bha', devanagari: 'भ', frequency: 1},
                    {latin: 'ma', devanagari: 'म', frequency: 1}
                ],
                autres: [
                    {latin: 'ya', devanagari: 'य', frequency: 1},
                    {latin: 'ra', devanagari: 'र', frequency: 1},
                    {latin: 'la', devanagari: 'ल', frequency: 1},
                    {latin: 'va', devanagari: 'व', frequency: 1},
                    {latin: 'śa', devanagari: 'श', frequency: 1},
                    {latin: 'sa', devanagari: 'स', frequency: 1},
                    {latin: 'ha', devanagari: 'ह', frequency: 1}
                ]
            };
            
            // Variables globales
            let currentGroup = 'all';
            let currentLetter = null;
            let practiceCount = 0;
            let successCount = 0;
            let isDrawing = false;
            let canvas = document.getElementById('drawingCanvas');
            let ctx = canvas.getContext('2d');
            let referenceCanvas = document.getElementById('referenceCanvas');
            let refCtx = referenceCanvas.getContext('2d');
            let comparisonCanvas = document.getElementById('comparisonCanvas');
            let compCtx = comparisonCanvas.getContext('2d');
            let lastSimilarityScore = 0;
            let trainingData = null; // Données d'entraînement ML
            let showingDevanagari = false; // État d'affichage de la lettre
            
            // Configuration du canvas
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Charger les données d'entraînement
            loadTrainingData();
            
            // Initialisation
            loadNextLetter();
            updateStats();
            
            // Gestion des groupes de lettres
            $('.group-btn').click(function() {
                $('.group-btn').removeClass('active');
                $(this).addClass('active');
                currentGroup = $(this).data('group');
                loadNextLetter();
            });
            
            // Fonction pour obtenir les lettres du groupe sélectionné
            function getLettersFromGroup(group) {
                if (group === 'all') {
                    let allLetters = [];
                    Object.values(devanagariData).forEach(groupLetters => {
                        allLetters = allLetters.concat(groupLetters);
                    });
                    return allLetters;
                }
                return devanagariData[group] || [];
            }
            
            // Fonction pour charger la prochaine lettre basée sur la fréquence
            function loadNextLetter() {
                const letters = getLettersFromGroup(currentGroup);
                if (letters.length === 0) return;
                
                // Algorithme de sélection pondérée basé sur la fréquence
                const totalWeight = letters.reduce((sum, letter) => sum + letter.frequency, 0);
                let random = Math.random() * totalWeight;
                
                for (let letter of letters) {
                    random -= letter.frequency;
                    if (random <= 0) {
                        currentLetter = letter;
                        break;
                    }
                }
                
                if (!currentLetter) {
                    currentLetter = letters[0];
                }
                
                // Affichage
                $('#currentLetter').text(currentLetter.latin)
                                  .removeClass('devanagari')
                                  .addClass('latin');
                showingDevanagari = false;
                clearCanvas();
                
                // Initialiser le score temps réel
                $('#realtimeScore').text('Score en temps réel : 0%')
                    .css('background-color', '#f0f8ff')
                    .css('border-color', '#4a90e2')
                    .css('color', '#2c5aa0');
                    
                // Réinitialiser l'affichage de la lettre
                showingDevanagari = false;
            }
            
            // Gestion du canvas - Dessin
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // Support tactile
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                canvas.dispatchEvent(mouseEvent);
            });
            
            canvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                canvas.dispatchEvent(mouseEvent);
            });
            
            canvas.addEventListener('touchend', function(e) {
                e.preventDefault();
                const mouseEvent = new MouseEvent('mouseup', {});
                canvas.dispatchEvent(mouseEvent);
            });
            
            function startDrawing(e) {
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                ctx.beginPath();
                ctx.moveTo(x, y);
            }
            
            function draw(e) {
                if (!isDrawing) return;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                ctx.lineTo(x, y);
                ctx.stroke();
            }
            
            function stopDrawing() {
                isDrawing = false;
                
                // Mettre à jour le score en temps réel après un court délai
                if (realtimeTimeout) clearTimeout(realtimeTimeout);
                realtimeTimeout = setTimeout(updateRealtimeScore, 300);
            }
            
            function clearCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Remettre le score à zéro
                $('#realtimeScore').text('Score en temps réel : 0%')
                    .css('background-color', '#f0f8ff')
                    .css('border-color', '#4a90e2')
                    .css('color', '#2c5aa0');
            }
            
            // Boutons de contrôle
            $('#clearBtn').click(function() {
                clearCanvas();
                $('#similarityScore').hide();
                $('#canvasContainer').hide();
            });
            
            $('#analyzeBtn').click(function() {
                analyzeDrawing();
            });
            
            $('#nextBtn').click(function() {
                loadNextLetter();
                $('#similarityScore').hide();
                $('#canvasContainer').hide();
            });
            
            // Clic sur la lettre pour basculer entre latin et devanagari
            $('#currentLetter').click(function() {
                if (!currentLetter) return;
                
                const $letter = $(this);
                
                if (showingDevanagari) {
                    // Retour au latin
                    $letter.text(currentLetter.latin)
                           .removeClass('devanagari')
                           .addClass('latin');
                    showingDevanagari = false;
                } else {
                    // Basculer vers devanagari
                    $letter.text(currentLetter.devanagari)
                           .removeClass('latin')
                           .addClass('devanagari');
                    showingDevanagari = true;
                }
            });
            
            // Évaluation
            $('#okBtn').click(function() {
                evaluateLetter(true);
            });
            
            $('#nokBtn').click(function() {
                evaluateLetter(false);
            });
            
            function evaluateLetter(success) {
                practiceCount++;
                if (success) {
                    successCount++;
                    // Diminuer la fréquence (la lettre apparaîtra moins souvent)
                    currentLetter.frequency = Math.max(0.1, currentLetter.frequency * 0.8);
                } else {
                    // Augmenter la fréquence (la lettre apparaîtra plus souvent)
                    currentLetter.frequency = Math.min(3, currentLetter.frequency * 1.5);
                }
                
                updateStats();
                setTimeout(loadNextLetter, 500);
            }
            
            function updateStats() {
                $('#practiceCount').text(practiceCount);
                $('#successCount').text(successCount);
                const rate = practiceCount > 0 ? Math.round((successCount / practiceCount) * 100) : 0;
                $('#successRate').text(rate + '%');
            }
            
            // Fonction pour dessiner la lettre de référence avec trait plus fin
            function drawReference() {
                refCtx.clearRect(0, 0, referenceCanvas.width, referenceCanvas.height);
                
                // Utiliser strokeText au lieu de fillText pour des traits plus fins
                refCtx.font = '100px "Noto Sans Devanagari"'; // Réduit de 120 à 100
                refCtx.strokeStyle = '#333';
                refCtx.lineWidth = 2; // Trait fin
                refCtx.lineCap = 'round';
                refCtx.lineJoin = 'round';
                refCtx.textAlign = 'center';
                refCtx.textBaseline = 'middle';
                refCtx.strokeText(currentLetter.devanagari, referenceCanvas.width/2, referenceCanvas.height/2);
                
                // Ajouter un peu de remplissage très léger
                refCtx.fillStyle = 'rgba(51, 51, 51, 0.3)';
                refCtx.fillText(currentLetter.devanagari, referenceCanvas.width/2, referenceCanvas.height/2);
            }
            
            // Fonction pour analyser la similitudedepuis le dessin
            function analyzeDrawing() {
                if (!currentLetter) return;
                
                // Dessiner la référence
                drawReference();
                
                // Redimensionner le dessin utilisateur pour la comparaison
                const userCanvas = document.createElement('canvas');
                userCanvas.width = 200;
                userCanvas.height = 200;
                const userCtx = userCanvas.getContext('2d');
                userCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, 200, 200);
                
                // Obtenir les données des pixels
                const refData = refCtx.getImageData(0, 0, 200, 200);
                const userImageData = userCtx.getImageData(0, 0, 200, 200);
                
                // Calculer la similitude
                const similarity = calculateSimilarity(refData, userImageData);
                lastSimilarityScore = similarity;
                
                // Créer la visualisation de comparaison
                createComparisonVisualization(refData, userImageData);
                
                // Afficher le résultat
                displaySimilarityScore(similarity);
                
                $('#similarityScore').show();
                $('#canvasContainer').show();
            }
            
            // Fonction pour extraire les contours d'une image
            function extractContours(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const edges = [];
                
                // Détection de contours simple (Sobel approximé)
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Vérifier si le pixel est dessinné (noir ou alpha élevé)
                        const isDrawn = data[idx + 3] > 100 || 
                                       (data[idx] < 128 && data[idx + 1] < 128 && data[idx + 2] < 128);
                        
                        if (isDrawn) {
                            // Calculer le gradient
                            const gx = getPixelIntensity(data, x + 1, y, width) - getPixelIntensity(data, x - 1, y, width);
                            const gy = getPixelIntensity(data, x, y + 1, width) - getPixelIntensity(data, x, y - 1, width);
                            const magnitude = Math.sqrt(gx * gx + gy * gy);
                            
                            if (magnitude > 50) {
                                edges.push({x: x, y: y, magnitude: magnitude});
                            }
                        }
                    }
                }
                return edges;
            }
            
            function getPixelIntensity(data, x, y, width) {
                const idx = (y * width + x) * 4;
                if (idx < 0 || idx >= data.length) return 0;
                
                // Intensité basée sur alpha et couleur
                const alpha = data[idx + 3];
                const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                return alpha > 100 ? (255 - gray) : 0;
            }
            
            // Fonction pour calculer les moments géométriques
            function calculateMoments(contours, width, height) {
                if (contours.length === 0) return { m00: 0, m10: 0, m01: 0, mu20: 0, mu11: 0, mu02: 0 };
                
                // Moments de base
                let m00 = 0, m10 = 0, m01 = 0;
                for (let point of contours) {
                    const weight = point.magnitude || 1;
                    m00 += weight;
                    m10 += point.x * weight;
                    m01 += point.y * weight;
                }
                
                // Centre de masse
                const cx = m00 > 0 ? m10 / m00 : width / 2;
                const cy = m00 > 0 ? m01 / m00 : height / 2;
                
                // Moments centraux
                let mu20 = 0, mu11 = 0, mu02 = 0;
                for (let point of contours) {
                    const weight = point.magnitude || 1;
                    const dx = point.x - cx;
                    const dy = point.y - cy;
                    mu20 += dx * dx * weight;
                    mu11 += dx * dy * weight;
                    mu02 += dy * dy * weight;
                }
                
                return { m00, m10, m01, mu20, mu11, mu02, cx, cy };
            }
            
            // Fonction pour calculer les caractéristiques de forme
            function calculateShapeFeatures(contours, width, height) {
                if (contours.length === 0) {
                    return {
                        density: 0,
                        aspectRatio: 1,
                        compactness: 0,
                        centroidX: 0.5,
                        centroidY: 0.5,
                        spread: 0,
                        connectivity: 0,
                        verticalDistribution: 0,
                        horizontalDistribution: 0,
                        topHeaviness: 0
                    };
                }
                
                const moments = calculateMoments(contours, width, height);
                
                // Densité (nombre de points de contour)
                const density = contours.length / (width * height);
                
                // Boîte englobante
                let minX = width, maxX = 0, minY = height, maxY = 0;
                for (let point of contours) {
                    minX = Math.min(minX, point.x);
                    maxX = Math.max(maxX, point.x);
                    minY = Math.min(minY, point.y);
                    maxY = Math.max(maxY, point.y);
                }
                
                const boundingWidth = maxX - minX + 1;
                const boundingHeight = maxY - minY + 1;
                const aspectRatio = boundingWidth / boundingHeight;
                
                // Compacité (circulaire = 1, allongé < 1)
                const area = contours.length;
                const perimeter = Math.sqrt(boundingWidth * boundingWidth + boundingHeight * boundingHeight);
                const compactness = area > 0 ? (4 * Math.PI * area) / (perimeter * perimeter) : 0;
                
                // Centre de masse normalisé
                const centroidX = moments.cx / width;
                const centroidY = moments.cy / height;
                
                // Étalement (variance)
                const spread = moments.m00 > 0 ? (moments.mu20 + moments.mu02) / moments.m00 : 0;
                
                // *** NOUVELLES CARACTÉRISTIQUES SPÉCIFIQUES AU DEVANAGARI ***
                
                // Connectivité des contours (mesure la continuité)
                let connectivity = 0;
                for (let i = 0; i < contours.length; i++) {
                    let nearbyPoints = 0;
                    for (let j = 0; j < contours.length; j++) {
                        if (i !== j) {
                            const dx = contours[i].x - contours[j].x;
                            const dy = contours[i].y - contours[j].y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < 3) nearbyPoints++;
                        }
                    }
                    connectivity += nearbyPoints / contours.length;
                }
                connectivity = connectivity / contours.length;
                
                // Distribution verticale (important pour le devanagari)
                const verticalBins = 5;
                const binHeight = height / verticalBins;
                const verticalDist = new Array(verticalBins).fill(0);
                for (let point of contours) {
                    const bin = Math.min(Math.floor(point.y / binHeight), verticalBins - 1);
                    verticalDist[bin]++;
                }
                // Calculer l'entropie de la distribution verticale
                let verticalEntropy = 0;
                for (let count of verticalDist) {
                    if (count > 0) {
                        const p = count / contours.length;
                        verticalEntropy -= p * Math.log2(p);
                    }
                }
                const verticalDistribution = verticalEntropy / Math.log2(verticalBins);
                
                // Distribution horizontale
                const horizontalBins = 5;
                const binWidth = width / horizontalBins;
                const horizontalDist = new Array(horizontalBins).fill(0);
                for (let point of contours) {
                    const bin = Math.min(Math.floor(point.x / binWidth), horizontalBins - 1);
                    horizontalDist[bin]++;
                }
                let horizontalEntropy = 0;
                for (let count of horizontalDist) {
                    if (count > 0) {
                        const p = count / contours.length;
                        horizontalEntropy -= p * Math.log2(p);
                    }
                }
                const horizontalDistribution = horizontalEntropy / Math.log2(horizontalBins);
                
                // Top-heaviness (les lettres devanagari ont souvent plus de détails en haut)
                const topHalf = contours.filter(p => p.y < height / 2).length;
                const bottomHalf = contours.filter(p => p.y >= height / 2).length;
                const topHeaviness = topHalf / (topHalf + bottomHalf + 1);
                
                return {
                    density,
                    aspectRatio,
                    compactness,
                    centroidX,
                    centroidY,
                    spread: spread / (width * height),
                    connectivity,
                    verticalDistribution,
                    horizontalDistribution,
                    topHeaviness
                };
            }
            
            // Plus besoin de charger des données d'entraînement complexes
            async function loadTrainingData() {
                // Algorithme simplifié - pas de données externes nécessaires
            }
            
            // Convertir une image en matrice binaire
            function imageToBinary(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const binary = new Array(height).fill(null).map(() => new Array(width).fill(0));
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const alpha = data[idx + 3];
                        const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        
                        // Pixel dessinné si alpha élevé ou couleur foncée
                        binary[y][x] = (alpha > 100 || gray < 200) ? 1 : 0;
                    }
                }
                
                return binary;
            }
            
            // Calculer les projections horizontales et verticales
            function calculateProjections(binary) {
                const height = binary.length;
                const width = binary[0].length;
                
                // Projection horizontale (somme par ligne)
                const horizontal = new Array(height).fill(0);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        horizontal[y] += binary[y][x];
                    }
                }
                
                // Projection verticale (somme par colonne)
                const vertical = new Array(width).fill(0);
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        vertical[x] += binary[y][x];
                    }
                }
                
                return { horizontal, vertical };
            }
            
            // Comparer deux projections
            function compareProjections(proj1, proj2) {
                if (proj1.length !== proj2.length) return 0;
                
                // Normaliser les projections
                const sum1 = proj1.reduce((a, b) => a + b, 0);
                const sum2 = proj2.reduce((a, b) => a + b, 0);
                
                if (sum1 === 0 && sum2 === 0) return 1;
                if (sum1 === 0 || sum2 === 0) return 0;
                
                const norm1 = proj1.map(v => v / sum1);
                const norm2 = proj2.map(v => v / sum2);
                
                // Corrélation croisée
                let correlation = 0;
                for (let i = 0; i < norm1.length; i++) {
                    correlation += norm1[i] * norm2[i];
                }
                
                return correlation;
            }
            
            // Calculer l'Intersection over Union (IoU)
            function calculateIoU(binary1, binary2) {
                const height = Math.min(binary1.length, binary2.length);
                const width = Math.min(binary1[0].length, binary2[0].length);
                
                let intersection = 0;
                let union = 0;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const pixel1 = binary1[y][x];
                        const pixel2 = binary2[y][x];
                        
                        if (pixel1 === 1 && pixel2 === 1) {
                            intersection++;
                        }
                        if (pixel1 === 1 || pixel2 === 1) {
                            union++;
                        }
                    }
                }
                
                return union > 0 ? intersection / union : 0;
            }
            
            // Calculer des signatures simples de forme
            function calculateSignature(binary) {
                const height = binary.length;
                const width = binary[0].length;
                
                let totalPixels = 0;
                let centerX = 0, centerY = 0;
                let minX = width, maxX = 0, minY = height, maxY = 0;
                
                // Calculer centre de masse et boîte englobante
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (binary[y][x] === 1) {
                            totalPixels++;
                            centerX += x;
                            centerY += y;
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                
                if (totalPixels === 0) {
                    return { density: 0, aspectRatio: 1, centerX: 0.5, centerY: 0.5, spread: 0 };
                }
                
                centerX /= totalPixels;
                centerY /= totalPixels;
                
                const density = totalPixels / (width * height);
                const aspectRatio = (maxY - minY + 1) > 0 ? (maxX - minX + 1) / (maxY - minY + 1) : 1;
                
                // Calcul de l'étalement
                let spread = 0;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (binary[y][x] === 1) {
                            spread += (x - centerX) * (x - centerX) + (y - centerY) * (y - centerY);
                        }
                    }
                }
                spread = spread / totalPixels;
                
                return {
                    density,
                    aspectRatio,
                    centerX: centerX / width,
                    centerY: centerY / height,
                    spread: spread / (width * height)
                };
            }
            
            // Fonction de comparaison avec alignement et normalisation
            function calculateSimilarity(refData, userData) {
                // Comparaison avec alignement
                
                try {
                    // 1. Détecter les bounding boxes
                    const refBbox = getBoundingBox(refData);
                    const userBbox = getBoundingBox(userData);
                    
                    // Détection des bounding boxes effectuée
                    
                    // Si pas de dessin utilisateur
                    if (userBbox.pixelCount === 0) {
                        return 0; // Aucun dessin utilisateur
                    }
                    
                    // Si pas de référence (problème)
                    if (refBbox.pixelCount === 0) {
                        // Pas de référence - score basé sur la complexité
                        if (userBbox.pixelCount < 50) return 15;
                        if (userBbox.pixelCount < 200) return 35;
                        if (userBbox.pixelCount < 500) return 55;
                        return 25;
                    }
                    
                    // 2. Extraire et normaliser les régions d'intérêt
                    const refNormalized = extractAndNormalize(refData, refBbox, 80);
                    const userNormalized = extractAndNormalize(userData, userBbox, 80);
                    
                    // 3. Comparer les images alignées
                    const comparison = compareAlignedImages(refNormalized, userNormalized);
                    
                    // 4. Calculer le score avec compensation pour les différences d'épaisseur
                    let baseScore = 0;
                    
                    // Score principal basé sur IoU
                    const iouScore = comparison.iou * 100;
                    
                    // Score basé sur la précision (important pour éviter le bruit)
                    const precisionScore = comparison.precision * 100;
                    
                    // Score basé sur le rappel (important pour capturer la forme)
                    const recallScore = comparison.recall * 100;
                    
                    // Score F1
                    const f1Score = comparison.precision + comparison.recall > 0 ? 
                        (2 * comparison.precision * comparison.recall) / (comparison.precision + comparison.recall) * 100 : 0;
                    
                    // Si le rapport de pixels est très déséquilibré (comme 1628 vs 307), privilégier la précision
                    const pixelRatio = Math.min(comparison.userPixels, comparison.refPixels) / Math.max(comparison.userPixels, comparison.refPixels);
                    
                    if (pixelRatio < 0.3) {
                        // Cas de traits très différents : privilégier précision et forme
                        baseScore = (precisionScore * 0.6) + (recallScore * 0.4);
                        // Mode compensation épaisseur activé
                    } else {
                        // Cas normal : utiliser IoU et F1
                        baseScore = (iouScore * 0.6) + (f1Score * 0.4);
                    }
                    
                    // Calcul des scores effectué
                    
                    // 5. Ajustements et bonus
                    let finalScore = baseScore;
                    
                    // Bonus pour forme complexe (encourage les vrais essais)
                    if (userBbox.pixelCount > 100) {
                        finalScore += 10; // Augmenté de 5 à 10
                        // Bonus complexité: +10
                    }
                    
                    // Bonus pour proportions correctes
                    const refAspect = refBbox.width / refBbox.height;
                    const userAspect = userBbox.width / userBbox.height;
                    const aspectDiff = Math.abs(refAspect - userAspect) / Math.max(refAspect, userAspect);
                    
                    if (aspectDiff < 0.4) { // Plus tolérant : 0.4 au lieu de 0.3
                        finalScore += 15; // Augmenté de 10 à 15
                        // Bonus proportions: +15
                    }
                    
                    // Bonus spécial pour haute précision (dessins soignés)
                    if (comparison.precision > 0.4) {
                        finalScore += 15;
                        // Bonus précision: +15
                    }
                    
                    // Bonus pour bon rappel (forme capturée)
                    if (comparison.recall > 0.15) {
                        finalScore += 10;
                        // Bonus rappel: +10
                    }
                    
                    // Pénalité pour dessins trop simples
                    if (userBbox.pixelCount < 50) {
                        finalScore -= 20;
                        // Pénalité simplicité: -20
                    }
                    
                    // Limiter entre 5 et 100
                    finalScore = Math.max(5, Math.min(100, finalScore));
                    
                    // Calcul du score final terminé
                    
                    return Math.round(finalScore);
                    
                } catch (error) {
                    // Erreur de calcul
                    return 25;
                }
            }
            
            // Détecter si un pixel est dessinné
            function isPixelDrawn(r, g, b, alpha) {
                return (r < 150 && g < 150 && b < 150) && alpha > 200;
            }
            
            // Trouver la bounding box d'un dessin
            function getBoundingBox(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                let minX = width, maxX = -1, minY = height, maxY = -1;
                let pixelCount = 0;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        const alpha = data[idx + 3];
                        
                        if (isPixelDrawn(r, g, b, alpha)) {
                            pixelCount++;
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                
                // Si aucun pixel dessinné, retourner une box vide
                if (pixelCount === 0) {
                    return { minX: 0, maxX: 0, minY: 0, maxY: 0, width: 0, height: 0, pixelCount: 0 };
                }
                
                return {
                    minX, maxX, minY, maxY,
                    width: maxX - minX + 1,
                    height: maxY - minY + 1,
                    pixelCount
                };
            }
            
            // Extraire la région d'intérêt et la normaliser
            function extractAndNormalize(imageData, bbox, targetSize = 80) {
                if (bbox.pixelCount === 0) {
                    // Retourner une image vide
                    const emptyData = new Uint8ClampedArray(targetSize * targetSize * 4);
                    emptyData.fill(255); // Blanc
                    return new ImageData(emptyData, targetSize, targetSize);
                }
                
                const data = imageData.data;
                const width = imageData.width;
                
                // Ajouter une marge de 10% autour de la bounding box
                const margin = Math.max(2, Math.round(Math.max(bbox.width, bbox.height) * 0.1));
                const cropMinX = Math.max(0, bbox.minX - margin);
                const cropMaxX = Math.min(width - 1, bbox.maxX + margin);
                const cropMinY = Math.max(0, bbox.minY - margin);
                const cropMaxY = Math.min(imageData.height - 1, bbox.maxY + margin);
                
                const cropWidth = cropMaxX - cropMinX + 1;
                const cropHeight = cropMaxY - cropMinY + 1;
                
                // Extraction et normalisation effectuées
                
                // Créer l'image normalisée
                const normalizedData = new Uint8ClampedArray(targetSize * targetSize * 4);
                normalizedData.fill(255); // Fond blanc
                
                // Redimensionner et copier
                const scaleX = cropWidth / targetSize;
                const scaleY = cropHeight / targetSize;
                
                for (let y = 0; y < targetSize; y++) {
                    for (let x = 0; x < targetSize; x++) {
                        // Coordonnées dans l'image originale
                        const origX = Math.round(cropMinX + x * scaleX);
                        const origY = Math.round(cropMinY + y * scaleY);
                        
                        if (origX < width && origY < imageData.height) {
                            const origIdx = (origY * width + origX) * 4;
                            const normIdx = (y * targetSize + x) * 4;
                            
                            normalizedData[normIdx] = data[origIdx];     // R
                            normalizedData[normIdx + 1] = data[origIdx + 1]; // G
                            normalizedData[normIdx + 2] = data[origIdx + 2]; // B
                            normalizedData[normIdx + 3] = data[origIdx + 3]; // A
                        }
                    }
                }
                
                return new ImageData(normalizedData, targetSize, targetSize);
            }
            
            // Comparer deux images alignées avec tolérance pour l'épaisseur de trait
            function compareAlignedImages(refImage, userImage) {
                const refData = refImage.data;
                const userData = userImage.data;
                const width = refImage.width;
                const height = refImage.height;
                
                let refPixels = 0, userPixels = 0, matchPixels = 0, nearMatches = 0;
                
                // Première passe : compter les pixels
                for (let i = 0; i < refData.length; i += 4) {
                    const refDrawn = isPixelDrawn(refData[i], refData[i + 1], refData[i + 2], refData[i + 3]);
                    const userDrawn = isPixelDrawn(userData[i], userData[i + 1], userData[i + 2], userData[i + 3]);
                    
                    if (refDrawn) refPixels++;
                    if (userDrawn) userPixels++;
                    if (refDrawn && userDrawn) matchPixels++;
                }
                
                // Deuxième passe : chercher des correspondances proches pour compenser les différences d'épaisseur
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const userDrawn = isPixelDrawn(userData[idx], userData[idx + 1], userData[idx + 2], userData[idx + 3]);
                        
                        if (userDrawn) {
                            // Chercher des pixels de référence dans un rayon de 3 pixels
                            let foundNear = false;
                            for (let dy = -3; dy <= 3 && !foundNear; dy++) {
                                for (let dx = -3; dx <= 3 && !foundNear; dx++) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                        const nIdx = (ny * width + nx) * 4;
                                        const refDrawn = isPixelDrawn(refData[nIdx], refData[nIdx + 1], refData[nIdx + 2], refData[nIdx + 3]);
                                        if (refDrawn) {
                                            nearMatches++;
                                            foundNear = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Calculer IoU avec les correspondances proches
                const adjustedMatches = Math.max(matchPixels, nearMatches * 0.7); // 70% de crédit pour les correspondances proches
                const union = refPixels + userPixels - adjustedMatches;
                const iou = union > 0 ? adjustedMatches / union : 0;
                
                // Calculer précision et rappel ajustés
                const precision = userPixels > 0 ? adjustedMatches / userPixels : 0;
                const recall = refPixels > 0 ? adjustedMatches / refPixels : 0;
                
                // Comparaison alignée effectuée
                
                return { iou, precision, recall, refPixels, userPixels, matchPixels: adjustedMatches };
            }
            
            // Compter les pixels dessinnés dans une image (fonction simplifiée)
            function countDrawnPixels(imageData) {
                const bbox = getBoundingBox(imageData);
                return bbox.pixelCount;
            }
            
            // Fonction pour créer la visualisation de comparaison avec images alignées
            function createComparisonVisualization(refData, userData) {
                compCtx.clearRect(0, 0, comparisonCanvas.width, comparisonCanvas.height);
                
                try {
                    // Obtenir les bounding boxes
                    const refBbox = getBoundingBox(refData);
                    const userBbox = getBoundingBox(userData);
                    
                    if (refBbox.pixelCount === 0 || userBbox.pixelCount === 0) {
                        compCtx.fillStyle = '#666';
                        compCtx.font = '14px Arial';
                        compCtx.fillText('Pas de comparaison possible', 10, 100);
                        return;
                    }
                    
                    // Normaliser les deux images à 80x80
                    const refNormalized = extractAndNormalize(refData, refBbox, 80);
                    const userNormalized = extractAndNormalize(userData, userBbox, 80);
                    
                    // Créer des canvas temporaires pour affichage
                    const tempRefCanvas = document.createElement('canvas');
                    const tempUserCanvas = document.createElement('canvas');
                    tempRefCanvas.width = tempUserCanvas.width = 80;
                    tempRefCanvas.height = tempUserCanvas.height = 80;
                    
                    const tempRefCtx = tempRefCanvas.getContext('2d');
                    const tempUserCtx = tempUserCanvas.getContext('2d');
                    
                    tempRefCtx.putImageData(refNormalized, 0, 0);
                    tempUserCtx.putImageData(userNormalized, 0, 0);
                    
                    // Dessiner les images alignées côte à côte
                    compCtx.drawImage(tempRefCanvas, 10, 10, 80, 80);
                    compCtx.drawImage(tempUserCanvas, 110, 10, 80, 80);
                    
                    // Superposition pour comparaison directe
                    compCtx.globalAlpha = 0.5;
                    compCtx.fillStyle = '#ff6666';
                    compCtx.drawImage(tempRefCanvas, 10, 110, 80, 80);
                    compCtx.fillStyle = '#6666ff';
                    compCtx.drawImage(tempUserCanvas, 10, 110, 80, 80);
                    compCtx.globalAlpha = 1.0;
                    
                    // Légendes
                    compCtx.fillStyle = '#333';
                    compCtx.font = '12px Arial';
                    compCtx.fillText('Référence', 15, 105);
                    compCtx.fillText('Votre dessin', 115, 105);
                    compCtx.fillText('Superposition', 15, 205);
                    
                } catch (error) {
                    // Erreur de visualisation
                    compCtx.fillStyle = '#666';
                    compCtx.font = '14px Arial';
                    compCtx.fillText('Erreur de visualisation', 10, 100);
                }
            }
            
            // Fonction pour afficher le score de similitude
            function displaySimilarityScore(score) {
                $('#scoreValue').text(score + '%');
                
                let color = '';
                
                if (score >= 80) {
                    color = '#28a745';
                } else if (score >= 60) {
                    color = '#17a2b8';
                } else if (score >= 40) {
                    color = '#ffc107';
                } else if (score >= 25) {
                    color = '#fd7e14';
                } else {
                    color = '#dc3545';
                }
                
                $('#scoreValue').css('color', color);
            }
            
            // Fonction pour mettre à jour le score en temps réel
            function updateRealtimeScore() {
                if (!currentLetter) return;
                
                try {
                    // Régénérer la référence
                    drawReference();
                    const refData = refCtx.getImageData(0, 0, referenceCanvas.width, referenceCanvas.height);
                    
                    // Obtenir le dessin utilisateur
                    const userCanvas = document.createElement('canvas');
                    userCanvas.width = 200;
                    userCanvas.height = 200;
                    const userCtx = userCanvas.getContext('2d');
                    userCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, 200, 200);
                    const userData = userCtx.getImageData(0, 0, 200, 200);
                    
                    // Calculer le score
                    const score = calculateSimilarity(refData, userData);
                    
                    // Mettre à jour l'affichage
                    const scoreElement = $('#realtimeScore');
                    scoreElement.text(`Score en temps réel : ${score}%`);
                    
                    // Couleur selon le score
                    if (score >= 70) {
                        scoreElement.css('background-color', '#d4edda').css('border-color', '#28a745').css('color', '#155724');
                    } else if (score >= 50) {
                        scoreElement.css('background-color', '#d1ecf1').css('border-color', '#17a2b8').css('color', '#0c5460');
                    } else if (score >= 30) {
                        scoreElement.css('background-color', '#fff3cd').css('border-color', '#ffc107').css('color', '#856404');
                    } else {
                        scoreElement.css('background-color', '#f8d7da').css('border-color', '#dc3545').css('color', '#721c24');
                    }
                    
                } catch (error) {
                    // Erreur score temps réel
                }
            }
            
            // Variable pour éviter trop de calculs
            let realtimeTimeout = null;
            
            // Modifier l'évaluation pour utiliser le score automatique
            function evaluateLetter(success) {
                practiceCount++;
                
                // Utiliser le score automatique si disponible (seuil plus accessible)
                if (lastSimilarityScore > 0) {
                    success = lastSimilarityScore >= 45;
                }
                
                if (success) {
                    successCount++;
                    currentLetter.frequency = Math.max(0.1, currentLetter.frequency * 0.8);
                } else {
                    currentLetter.frequency = Math.min(3, currentLetter.frequency * 1.5);
                }
                
                updateStats();
                setTimeout(function() {
                    loadNextLetter();
                    lastSimilarityScore = 0;
                }, 1000);
            }
        });
    </script>
</body>
</html>